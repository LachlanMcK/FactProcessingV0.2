"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
//import  mongoose from "mongoose";
//import * as mongoose  from "mongoose";
const myLog = __importStar(require("../../myLog"));
const mongoose = require("mongoose"); //https://stackoverflow.com/questions/34482136/mongoose-the-typescript-way
// define the shape of the Line Items part of Forms
const LineItemDef = {
    FieldId: String,
    FieldIndex: Number,
    Value: Object
};
let LineItemsSchema = new mongoose.Schema(LineItemDef);
// define the shape of the sections part of Forms
// sections are made up of Line Items
const SectionDef = {
    SectionId: String,
    SectionName: String,
    LineItems: [LineItemsSchema]
};
let SectionSchema = new mongoose.Schema(SectionDef);
// define the shape of Forms
// Forms are made up of Sections which are made up of Line Items
exports.FormDef = {
    ClientInternalId: {
        type: Number,
        required: false
    },
    AccountSequenceNumber: Number,
    RoleTypeCode: Number,
    PeriodStartDt: Date,
    FormType: {
        type: String,
        required: true
    },
    TransactionId: {
        type: Number,
        required: true
    },
    workItemId: String,
    Sections: [SectionSchema],
    createdAt: Date,
    updatedAt: Date,
    DT_Update: String,
    TM_Update: String,
    subjectClient: {
        ClientIdentifierType: String,
        ClientIdentifierValue: Number,
        MatchingStatus: String
    },
    ProcessingStatusCd: Number,
    ErrorCd: String,
    TransmissionDetails: {
        ClientIdentifierType: String,
        ClientIdentifierValue: Number,
        TransmissionBET: Number,
        TransmissionReference: Number,
        ThreadId: Number,
        RecordCount: Number
    }
};
let FormSchema = new mongoose.Schema(exports.FormDef, { discriminatorKey: 'kind' });
//This is the default
const FormCollectionDetails = {
    collection: 'Forms',
    versionKey: false
};
function setFootprintProperties(form, updateOnlyFlag) {
    const now = new Date();
    if ((form.DT_Update || form.TM_Update) && !(form.updatedAt))
        throw "updatedAt must exist if DT/TM_Updated fields are populated";
    if (!form.createdAt && !(updateOnlyFlag)) {
        //arguably don't need a createdAt field as it can be obtained from _id  https://docs.mongodb.com/manual/reference/method/ObjectId.getTimestamp/
        // form.createdAt = now;
        //should only set the createdAt when creating.  This feature should only matter if they forget to return the createdAt field on an update.
        //but if they do forget that, what else are they forgetting??
        form["$setOnInsert"] = { createdAt: now };
    }
    form.updatedAt = now;
    //todo: investigate making this virtual
    form.DT_Update = now.toLocaleDateString();
    form.TM_Update = now.toLocaleTimeString();
    return form;
}
exports.setFootprintProperties = setFootprintProperties;
FormSchema.index({ TransactionId: 1 }, { unique: true, name: "primary" });
FormSchema.index({ "subjectClient.ClientIdentifierValue": 1, "subjectClient.ClientIdentifierType": 1, "AccountSequenceNumber": 1, "RoleTypeCode": 1 }, { unique: false, name: "Carpat" });
FormSchema.index({ "subjectClient.ClientIdentifierValue": 1, "subjectClient.ClientIdentifierType": 1, "formType": 1 }, { unique: false, name: "clientExtIdByForm" });
FormSchema.index({ ClientInternalId: 1, formType: 1 }, { sparse: true, name: "clientIntIdByForm" });
FormSchema.index({ workItemId: 1 }, { sparse: true });
//todo: this is fine for dev but need to tidy this up
FormSchema.set('autoIndex', true);
//FormSchema.set('autoIndex', false);
exports.BaseForm = mongoose.model('Form', FormSchema);
let mongooseModels = {};
function Form(formType, formSpecificLineItemSchema) {
    if (!formType)
        return exports.BaseForm;
    if (!mongooseModels[formType]) {
        mongooseModels[formType] = exports.BaseForm.discriminator(formType, new mongoose.Schema(formSpecificLineItemSchema));
        myLog.debug("Additional " + formType + " line items schema definition ");
        myLog.log("Discriminated schema for: " + formType, formSpecificLineItemSchema);
    }
    myLog.debug("Returning discriminated schema for:" + formType);
    return mongooseModels[formType];
}
exports.Form = Form;
exports.HistorySchema = new mongoose.Schema({
    TransactionId: {
        type: Number,
        required: true
    },
    DT_Update: String,
    TM_Update: String,
    history: {}
}, { versionKey: false });
exports.HistorySchema.index({ TransactionId: 1, DT_Update: 1, TM_Update: 1 }, { unique: true, name: "primary" });
exports.HistoryForm = mongoose.model('FormHistory', exports.HistorySchema);
// export const PreFillSchema = new mongoose.Schema({
//   TransactionId: {
//     type: Number,
//     required: true
//   },
//   FormType: {
//     type: String,
//     required: true
//   },
//   subjectClient: {
//     ClientIdentifierType: String,
//     ClientIdentifierValue: Number
//   },
//   createdAt: Date,
//   updatedAt: Date,
//   DT_Update: String,
//   TM_Update: String,
//   facts: [mongoose.Schema.Types.Mixed]
// }, { versionKey: false });
// //PreFillSchema.index({ TransactionId: 1, FormType: 1 }, { unique: true, name: "primary" });
// export const PreFillForm: mongoose.Model<mongoose.Document> = mongoose.model('prefillIITR', PreFillSchema);
exports.PreFillSchema2 = new mongoose.Schema({
    facts: [mongoose.Schema.Types.Mixed]
}, { versionKey: false });
//todo: take out of facts collection
//      got to confess, I only did this because I could and it tickled my fancy to do so.  Saved me having to write separate Get/Delete (for testing)
//      but prefill structure doesn't really look like fact structure, so I shouldn't do this.
exports.PreFillForm = exports.BaseForm.discriminator('prefillIITRForm', new mongoose.Schema({ facts: [] }));
mongooseModels['prefillIITRForm'] = exports.PreFillForm;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkZvcm0udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbUNBQW1DO0FBQ25DLHdDQUF3QztBQUN4QyxtREFBcUM7QUFDckMscUNBQXNDLENBQUUsMEVBQTBFO0FBRWxILG1EQUFtRDtBQUNuRCxNQUFNLFdBQVcsR0FBRztJQUNsQixPQUFPLEVBQUUsTUFBTTtJQUNmLFVBQVUsRUFBRSxNQUFNO0lBQ2xCLEtBQUssRUFBRSxNQUFNO0NBQ2QsQ0FBQTtBQUVELElBQUksZUFBZSxHQUFHLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUV2RCxpREFBaUQ7QUFDakQscUNBQXFDO0FBQ3JDLE1BQU0sVUFBVSxHQUFHO0lBQ2pCLFNBQVMsRUFBRSxNQUFNO0lBQ2pCLFdBQVcsRUFBRSxNQUFNO0lBQ25CLFNBQVMsRUFBRSxDQUFDLGVBQWUsQ0FBQztDQUM3QixDQUFBO0FBRUQsSUFBSSxhQUFhLEdBQUcsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0FBRXBELDRCQUE0QjtBQUM1QixnRUFBZ0U7QUFDbkQsUUFBQSxPQUFPLEdBQUc7SUFDckIsZ0JBQWdCLEVBQUU7UUFDaEIsSUFBSSxFQUFFLE1BQU07UUFDWixRQUFRLEVBQUUsS0FBSztLQUNoQjtJQUNELHFCQUFxQixFQUFFLE1BQU07SUFDN0IsWUFBWSxFQUFFLE1BQU07SUFDcEIsYUFBYSxFQUFFLElBQUk7SUFDbkIsUUFBUSxFQUFFO1FBQ1IsSUFBSSxFQUFFLE1BQU07UUFDWixRQUFRLEVBQUUsSUFBSTtLQUNmO0lBQ0QsYUFBYSxFQUFFO1FBQ2IsSUFBSSxFQUFFLE1BQU07UUFDWixRQUFRLEVBQUUsSUFBSTtLQUNmO0lBQ0QsVUFBVSxFQUFFLE1BQU07SUFDbEIsUUFBUSxFQUFFLENBQUMsYUFBYSxDQUFDO0lBQ3pCLFNBQVMsRUFBRSxJQUFJO0lBQ2YsU0FBUyxF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RSxTQUFTLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsQ0FBQyxDQUFDO0FBQzVGLFFBQUEsV0FBVyxHQUFzQyxRQUFRLENBQUMsS0FBSyxDQUFDLGFBQWEsRUFBRSxxQkFBYSxDQUFDLENBQUM7QUFFM0cscURBQXFEO0FBQ3JELHFCQUFxQjtBQUNyQixvQkFBb0I7QUFDcEIscUJBQXFCO0FBQ3JCLE9BQU87QUFDUCxnQkFBZ0I7QUFDaEIsb0JBQW9CO0FBQ3BCLHFCQUFxQjtBQUNyQixPQUFPO0FBQ1AscUJBQXFCO0FBQ3JCLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMsT0FBTztBQUNQLHFCQUFxQjtBQUNyQixxQkFBcUI7QUFDckIsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2Qix5Q0FBeUM7QUFDekMsNkJBQTZCO0FBQzdCLCtGQUErRjtBQUMvRiw4R0FBOEc7QUFFakcsUUFBQSxjQUFjLEdBQUcsSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDO0lBQ2hELEtBQUssRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztDQUNyQyxFQUFFLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUM7QUFFMUIsb0NBQW9DO0FBQ3BDLHFKQUFxSjtBQUNySiw4RkFBOEY7QUFDakYsUUFBQSxXQUFXLEdBQXNDLGdCQUFRLENBQUMsYUFBYSxDQUFDLGlCQUFpQixFQUFFLElBQUksUUFBUSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDNUksY0FBYyxDQUFDLGlCQUFpQixDQUFDLEdBQUcsbUJBQVcsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vaW1wb3J0ICBtb25nb29zZSBmcm9tIFwibW9uZ29vc2VcIjtcclxuLy9pbXBvcnQgKiBhcyBtb25nb29zZSAgZnJvbSBcIm1vbmdvb3NlXCI7XHJcbmltcG9ydCAqIGFzIG15TG9nIGZyb20gJy4uLy4uL215TG9nJztcclxuaW1wb3J0IG1vbmdvb3NlID0gcmVxdWlyZSgnbW9uZ29vc2UnKTsgIC8vaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzQ0ODIxMzYvbW9uZ29vc2UtdGhlLXR5cGVzY3JpcHQtd2F5XHJcblxyXG4vLyBkZWZpbmUgdGhlIHNoYXBlIG9mIHRoZSBMaW5lIEl0ZW1zIHBhcnQgb2YgRm9ybXNcclxuY29uc3QgTGluZUl0ZW1EZWYgPSB7XHJcbiAgRmllbGRJZDogU3RyaW5nLFxyXG4gIEZpZWxkSW5kZXg6IE51bWJlcixcclxuICBWYWx1ZTogT2JqZWN0XHJcbn1cclxuXHJcbmxldCBMaW5lSXRlbXNTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKExpbmVJdGVtRGVmKTtcclxuXHJcbi8vIGRlZmluZSB0aGUgc2hhcGUgb2YgdGhlIHNlY3Rpb25zIHBhcnQgb2YgRm9ybXNcclxuLy8gc2VjdGlvbnMgYXJlIG1hZGUgdXAgb2YgTGluZSBJdGVtc1xyXG5jb25zdCBTZWN0aW9uRGVmID0ge1xyXG4gIFNlY3Rpb25JZDogU3RyaW5nLFxyXG4gIFNlY3Rpb25OYW1lOiBTdHJpbmcsXHJcbiAgTGluZUl0ZW1zOiBbTGluZUl0ZW1zU2NoZW1hXVxyXG59XHJcblxyXG5sZXQgU2VjdGlvblNjaGVtYSA9IG5ldyBtb25nb29zZS5TY2hlbWEoU2VjdGlvbkRlZik7XHJcblxyXG4vLyBkZWZpbmUgdGhlIHNoYXBlIG9mIEZvcm1zXHJcbi8vIEZvcm1zIGFyZSBtYWRlIHVwIG9mIFNlY3Rpb25zIHdoaWNoIGFyZSBtYWRlIHVwIG9mIExpbmUgSXRlbXNcclxuZXhwb3J0IGNvbnN0IEZvcm1EZWYgPSB7XHJcbiAgQ2xpZW50SW50ZXJuYWxJZDoge1xyXG4gICAgdHlwZTogTnVtYmVyLFxyXG4gICAgcmVxdWlyZWQ6IGZhbHNlXHJcbiAgfSxcclxuICBBY2NvdW50U2VxdWVuY2VOdW1iZXI6IE51bWJlcixcclxuICBSb2xlVHlwZUNvZGU6IE51bWJlcixcclxuICBQZXJpb2RTdGFydER0OiBEYXRlLFxyXG4gIEZvcm1UeXBlOiB7XHJcbiAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICByZXF1aXJlZDogdHJ1ZVxyXG4gIH0sXHJcbiAgVHJhbnNhY3Rpb25JZDoge1xyXG4gICAgdHlwZTogTnVtYmVyLFxyXG4gICAgcmVxdWlyZWQ6IHRydWVcclxuICB9LFxyXG4gIHdvcmtJdGVtSWQ6IFN0cmluZyxcclxuICBTZWN0aW9uczogW1NlY3Rpb25TY2hlbWFdLFxyXG4gIGNyZWF0ZWRBdDogRGF0ZSxcclxuICB1cGRhdGVkQXQ6IERhdGUsXHJcbiAgRFRfVXBkYXRlOiBTdHJpbmcsXHJcbiAgVE1fVXBkYXRlOiBTdHJpbmcsXHJcbiAgc3ViamVjdENsaWVudDoge1xyXG4gICAgQ2xpZW50SWRlbnRpZmllclR5cGU6IFN0cmluZyxcclxuICAgIENsaWVudElkZW50aWZpZXJWYWx1ZTogTnVtYmVyLFxyXG4gICAgTWF0Y2hpbmdTdGF0dXM6IFN0cmluZ1xyXG4gIH0sXHJcbiAgUHJvY2Vzc2luZ1N0YXR1c0NkOiBOdW1iZXIsIC8vYSBjb2RlIHN0YXRlbWVudCBpbmRpY2F0aW5nIHdoZXJlIHByb2Nlc3Npbmcgb2YgdGhpcyBlbnRyeSBpcyB1cCB0b1xyXG4gIEVycm9yQ2Q6IFN0cmluZywgLy9pZiByZWNvcmQgaXMga2VwdCB3aXRoIGVycm9ycywgdGhpcyBpcyB0aGUgZXJyb3IgY29kZVxyXG4gIFRyYW5zbWlzc2lvbkRldGFpbHM6IHsgLy93aGVuIHRoZXJlIGlzIGEgVHJhbnNtaXNzaW9uQkVULCB0aGVyZSBzaG91bGQgYmUgYSBTdXBwbGllciB3aG8gd2FzIHRoZSBzb3VyY2Ugb2YgdGhlIHRyYW5zbWlzc2lvblxyXG4gICAgQ2xpZW50SWRlbnRpZmllclR5cGU6IFN0cmluZyxcclxuICAgIENsaWVudElkZW50aWZpZXJWYWx1ZTogTnVtYmVyLFxyXG4gICAgVHJhbnNtaXNzaW9uQkVUOiBOdW1iZXIsICAvL3RoaXMgaXMgYSBiZXQgbnVtYmVyIGFsbG9jYXRlZCB0byBmaWxlcyBzbyBjYW4gY2FuY2VsIGFsbCByZWNvcmQgaW4gYSBmaWxlXHJcbiAgICBUcmFuc21pc3Npb25SZWZlcmVuY2U6IE51bWJlciwgIC8vdGhpcyBpcyB0aGUgcmVjb3JkL3Bvc2l0aW9uIG51bWJlciBpbiBhIGZpbGUgc28gd2hlbiBzZW5kIGVycm9yIG1lc3NhZ2VzIGNhbiByZWZlcmVuY2VzIHdoZXJlIGl0IGNhbWUgZnJvbVxyXG4gICAgVGhyZWFkSWQ6IE51bWJlciwgLy8gSWYgd2Ugc2hhcmQgdGhlIGJ1bGsgcHJvY2Vzc2luZyBvZiBmYWN0cywgd2UgbWF5IHdhbnQgdG8gY291bnQgYnkgc2hhcmRcclxuICAgIFJlY29yZENvdW50OiBOdW1iZXJcclxuICB9ICBcclxufVxyXG5cclxubGV0IEZvcm1TY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKEZvcm1EZWYsIHsgZGlzY3JpbWluYXRvcktleTogJ2tpbmQnIH0pO1xyXG5cclxuLy9UaGlzIGlzIHRoZSBkZWZhdWx0XHJcbmNvbnN0IEZvcm1Db2xsZWN0aW9uRGV0YWlscyA9IHtcclxuICBjb2xsZWN0aW9uOiAnRm9ybXMnLFxyXG4gIHZlcnNpb25LZXk6IGZhbHNlXHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBzZXRGb290cHJpbnRQcm9wZXJ0aWVzKGZvcm06IGFueSwgdXBkYXRlT25seUZsYWc/OiBCb29sZWFuKSB7XHJcbiAgY29uc3Qgbm93OiBEYXRlID0gbmV3IERhdGUoKTtcclxuICBpZiAoKGZvcm0uRFRfVXBkYXRlIHx8IGZvcm0uVE1fVXBkYXRlKSAmJiAhKGZvcm0udXBkYXRlZEF0KSkgdGhyb3cgXCJ1cGRhdGVkQXQgbXVzdCBleGlzdCBpZiBEVC9UTV9VcGRhdGVkIGZpZWxkcyBhcmUgcG9wdWxhdGVkXCJcclxuICBpZiAoIWZvcm0uY3JlYXRlZEF0ICYmICEodXBkYXRlT25seUZsYWcpKSB7XHJcbiAgICAvL2FyZ3VhYmx5IGRvbid0IG5lZWQgYSBjcmVhdGVkQXQgZmllbGQgYXMgaXQgY2FuIGJlIG9idGFpbmVkIGZyb20gX2lkICBodHRwczovL2RvY3MubW9uZ29kYi5jb20vbWFudWFsL3JlZmVyZW5jZS9tZXRob2QvT2JqZWN0SWQuZ2V0VGltZXN0YW1wL1xyXG4gICAgLy8gZm9ybS5jcmVhdGVkQXQgPSBub3c7XHJcbiAgICAvL3Nob3VsZCBvbmx5IHNldCB0aGUgY3JlYXRlZEF0IHdoZW4gY3JlYXRpbmcuICBUaGlzIGZlYXR1cmUgc2hvdWxkIG9ubHkgbWF0dGVyIGlmIHRoZXkgZm9yZ2V0IHRvIHJldHVybiB0aGUgY3JlYXRlZEF0IGZpZWxkIG9uIGFuIHVwZGF0ZS5cclxuICAgIC8vYnV0IGlmIHRoZXkgZG8gZm9yZ2V0IHRoYXQsIHdoYXQgZWxzZSBhcmUgdGhleSBmb3JnZXR0aW5nPz9cclxuICAgIGZvcm1bXCIkc2V0T25JbnNlcnRcIl0gPSB7IGNyZWF0ZWRBdDogbm93IH1cclxuICB9XHJcbiAgZm9ybS51cGRhdGVkQXQgPSBub3c7XHJcbiAgLy90b2RvOiBpbnZlc3RpZ2F0ZSBtYWtpbmcgdGhpcyB2aXJ0dWFsXHJcbiAgZm9ybS5EVF9VcGRhdGUgPSBub3cudG9Mb2NhbGVEYXRlU3RyaW5nKCk7XHJcbiAgZm9ybS5UTV9VcGRhdGUgPSBub3cudG9Mb2NhbGVUaW1lU3RyaW5nKCk7XHJcbiAgcmV0dXJuIGZvcm07XHJcbn1cclxuXHJcbkZvcm1TY2hlbWEuaW5kZXgoeyBUcmFuc2FjdGlvbklkOiAxIH0sIHsgdW5pcXVlOiB0cnVlLCBuYW1lOiBcInByaW1hcnlcIiB9KTtcclxuRm9ybVNjaGVtYS5pbmRleCh7IFwic3ViamVjdENsaWVudC5DbGllbnRJZGVudGlmaWVyVmFsdWVcIjogMSwgXCJzdWJqZWN0Q2xpZW50LkNsaWVudElkZW50aWZpZXJUeXBlXCI6IDEsIFwiQWNjb3VudFNlcXVlbmNlTnVtYmVyXCI6IDEsIFwiUm9sZVR5cGVDb2RlXCI6IDEgfSwgeyB1bmlxdWU6IGZhbHNlLCBuYW1lOiBcIkNhcnBhdFwiIH0pO1xyXG5cclxuRm9ybVNjaGVtYS5pbmRleCh7IFwic3ViamVjdENsaWVudC5DbGllbnRJZGVudGlmaWVyVmFsdWVcIjogMSwgXCJzdWJqZWN0Q2xpZW50LkNsaWVudElkZW50aWZpZXJUeXBlXCI6IDEsIFwiZm9ybVR5cGVcIjogMSB9LCB7IHVuaXF1ZTogZmFsc2UsIG5hbWU6IFwiY2xpZW50RXh0SWRCeUZvcm1cIiB9KTtcclxuRm9ybVNjaGVtYS5pbmRleCh7IENsaWVudEludGVybmFsSWQ6IDEsIGZvcm1UeXBlOiAxIH0sIHsgc3BhcnNlOiB0cnVlLCBuYW1lOiBcImNsaWVudEludElkQnlGb3JtXCIgfSk7XHJcbkZvcm1TY2hlbWEuaW5kZXgoeyB3b3JrSXRlbUlkOiAxIH0sIHsgc3BhcnNlOiB0cnVlIH0pO1xyXG5cclxuLy90b2RvOiB0aGlzIGlzIGZpbmUgZm9yIGRldiBidXQgbmVlZCB0byB0aWR5IHRoaXMgdXBcclxuRm9ybVNjaGVtYS5zZXQoJ2F1dG9JbmRleCcsIHRydWUpO1xyXG4vL0Zvcm1TY2hlbWEuc2V0KCdhdXRvSW5kZXgnLCBmYWxzZSk7XHJcblxyXG5leHBvcnQgY29uc3QgQmFzZUZvcm06IG1vbmdvb3NlLk1vZGVsPG1vbmdvb3NlLkRvY3VtZW50PiA9IG1vbmdvb3NlLm1vZGVsKCdGb3JtJywgRm9ybVNjaGVtYSk7XHJcblxyXG5sZXQgbW9uZ29vc2VNb2RlbHM6IGFueSA9IHt9O1xyXG5leHBvcnQgZnVuY3Rpb24gRm9ybShmb3JtVHlwZT86IHN0cmluZywgZm9ybVNwZWNpZmljTGluZUl0ZW1TY2hlbWE/OiBtb25nb29zZS5TY2hlbWEpOiBtb25nb29zZS5Nb2RlbDxtb25nb29zZS5Eb2N1bWVudD4ge1xyXG4gIGlmICghZm9ybVR5cGUpIHJldHVybiBCYXNlRm9ybTtcclxuXHJcbiAgaWYgKCFtb25nb29zZU1vZGVsc1tmb3JtVHlwZV0pIHtcclxuICAgIG1vbmdvb3NlTW9kZWxzW2Zvcm1UeXBlXSA9IEJhc2VGb3JtLmRpc2NyaW1pbmF0b3IoZm9ybVR5cGUsIG5ldyBtb25nb29zZS5TY2hlbWEoZm9ybVNwZWNpZmljTGluZUl0ZW1TY2hlbWEpKTtcclxuICAgIG15TG9nLmRlYnVnKFwiQWRkaXRpb25hbCBcIiArIGZvcm1UeXBlICsgXCIgbGluZSBpdGVtcyBzY2hlbWEgZGVmaW5pdGlvbiBcIik7XHJcbiAgICBteUxvZy5sb2coXCJEaXNjcmltaW5hdGVkIHNjaGVtYSBmb3I6IFwiICsgZm9ybVR5cGUsIGZvcm1TcGVjaWZpY0xpbmVJdGVtU2NoZW1hKTtcclxuICB9XHJcblxyXG4gIG15TG9nLmRlYnVnKFwiUmV0dXJuaW5nIGRpc2NyaW1pbmF0ZWQgc2NoZW1hIGZvcjpcIiArIGZvcm1UeXBlKTtcclxuICByZXR1cm4gbW9uZ29vc2VNb2RlbHNbZm9ybVR5cGVdO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgSGlzdG9yeVNjaGVtYSA9IG5ldyBtb25nb29zZS5TY2hlbWEoe1xyXG4gIFRyYW5zYWN0aW9uSWQ6IHtcclxuICAgIHR5cGU6IE51bWJlcixcclxuICAgIHJlcXVpcmVkOiB0cnVlXHJcbiAgfSxcclxuICBEVF9VcGRhdGU6IFN0cmluZyxcclxuICBUTV9VcGRhdGU6IFN0cmluZyxcclxuICBoaXN0b3J5OiB7fVxyXG59LCB7IHZlcnNpb25LZXk6IGZhbHNlIH0pO1xyXG5IaXN0b3J5U2NoZW1hLmluZGV4KHsgVHJhbnNhY3Rpb25JZDogMSwgRFRfVXBkYXRlOiAxLCBUTV9VcGRhdGU6IDEgfSwgeyB1bmlxdWU6IHRydWUsIG5hbWU6IFwicHJpbWFyeVwiIH0pO1xyXG5leHBvcnQgY29uc3QgSGlzdG9yeUZvcm06IG1vbmdvb3NlLk1vZGVsPG1vbmdvb3NlLkRvY3VtZW50PiA9IG1vbmdvb3NlLm1vZGVsKCdGb3JtSGlzdG9yeScsIEhpc3RvcnlTY2hlbWEpO1xyXG5cclxuLy8gZXhwb3J0IGNvbnN0IFByZUZpbGxTY2hlbWEgPSBuZXcgbW9uZ29vc2UuU2NoZW1hKHtcclxuLy8gICBUcmFuc2FjdGlvbklkOiB7XHJcbi8vICAgICB0eXBlOiBOdW1iZXIsXHJcbi8vICAgICByZXF1aXJlZDogdHJ1ZVxyXG4vLyAgIH0sXHJcbi8vICAgRm9ybVR5cGU6IHtcclxuLy8gICAgIHR5cGU6IFN0cmluZyxcclxuLy8gICAgIHJlcXVpcmVkOiB0cnVlXHJcbi8vICAgfSxcclxuLy8gICBzdWJqZWN0Q2xpZW50OiB7XHJcbi8vICAgICBDbGllbnRJZGVudGlmaWVyVHlwZTogU3RyaW5nLFxyXG4vLyAgICAgQ2xpZW50SWRlbnRpZmllclZhbHVlOiBOdW1iZXJcclxuLy8gICB9LFxyXG4vLyAgIGNyZWF0ZWRBdDogRGF0ZSxcclxuLy8gICB1cGRhdGVkQXQ6IERhdGUsXHJcbi8vICAgRFRfVXBkYXRlOiBTdHJpbmcsXHJcbi8vICAgVE1fVXBkYXRlOiBTdHJpbmcsXHJcbi8vICAgZmFjdHM6IFttb25nb29zZS5TY2hlbWEuVHlwZXMuTWl4ZWRdXHJcbi8vIH0sIHsgdmVyc2lvbktleTogZmFsc2UgfSk7XHJcbi8vIC8vUHJlRmlsbFNjaGVtYS5pbmRleCh7IFRyYW5zYWN0aW9uSWQ6IDEsIEZvcm1UeXBlOiAxIH0sIHsgdW5pcXVlOiB0cnVlLCBuYW1lOiBcInByaW1hcnlcIiB9KTtcclxuLy8gZXhwb3J0IGNvbnN0IFByZUZpbGxGb3JtOiBtb25nb29zZS5Nb2RlbDxtb25nb29zZS5Eb2N1bWVudD4gPSBtb25nb29zZS5tb2RlbCgncHJlZmlsbElJVFInLCBQcmVGaWxsU2NoZW1hKTtcclxuXHJcbmV4cG9ydCBjb25zdCBQcmVGaWxsU2NoZW1hMiA9IG5ldyBtb25nb29zZS5TY2hlbWEoe1xyXG4gIGZhY3RzOiBbbW9uZ29vc2UuU2NoZW1hLlR5cGVzLk1peGVkXVxyXG59LCB7IHZlcnNpb25LZXk6IGZhbHNlIH0pO1xyXG5cclxuLy90b2RvOiB0YWtlIG91dCBvZiBmYWN0cyBjb2xsZWN0aW9uXHJcbi8vICAgICAgZ290IHRvIGNvbmZlc3MsIEkgb25seSBkaWQgdGhpcyBiZWNhdXNlIEkgY291bGQgYW5kIGl0IHRpY2tsZWQgbXkgZmFuY3kgdG8gZG8gc28uICBTYXZlZCBtZSBoYXZpbmcgdG8gd3JpdGUgc2VwYXJhdGUgR2V0L0RlbGV0ZSAoZm9yIHRlc3RpbmcpXHJcbi8vICAgICAgYnV0IHByZWZpbGwgc3RydWN0dXJlIGRvZXNuJ3QgcmVhbGx5IGxvb2sgbGlrZSBmYWN0IHN0cnVjdHVyZSwgc28gSSBzaG91bGRuJ3QgZG8gdGhpcy5cclxuZXhwb3J0IGNvbnN0IFByZUZpbGxGb3JtOiBtb25nb29zZS5Nb2RlbDxtb25nb29zZS5Eb2N1bWVudD4gPSBCYXNlRm9ybS5kaXNjcmltaW5hdG9yKCdwcmVmaWxsSUlUUkZvcm0nLCBuZXcgbW9uZ29vc2UuU2NoZW1hKHsgZmFjdHM6IFtdIH0pKTtcclxubW9uZ29vc2VNb2RlbHNbJ3ByZWZpbGxJSVRSRm9ybSddID0gUHJlRmlsbEZvcm07XHJcbiJdfQ==