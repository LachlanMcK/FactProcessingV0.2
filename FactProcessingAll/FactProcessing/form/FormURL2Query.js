"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const myLog = __importStar(require("../../myLog"));
const FormController_1 = require("./FormController");
myLog.debug("in FormURL2Query");
function turnURLStemsIntoLookupObject(req, next) {
    let lookup = {};
    if (req.params.ClientInternalId)
        lookup.ClientInternalId = parseInt(req.params.ClientInternalId);
    if (req.params.AccountSequenceNumber)
        lookup.AccountSequenceNumber = parseInt(req.params.AccountSequenceNumber);
    if (req.params.RoleTypeShortDecode)
        lookup.RoleTypeCode = FormController_1.codeLookup(req.params.RoleTypeShortDecode);
    if (req.params.PeriodStartDt)
        lookup.PeriodStartDt = req.params.PeriodStartDt;
    //strip a "Form" suffix off here.  Its dumb. But trying to align with published URI.
    if (req.params.FormTypeMung) {
        if (!req.params.FormTypeMung.toLowerCase().endsWith("form"))
            next(new Error("Invalid FormType Stem"));
        lookup.FormType = req.params.FormTypeMung.slice(0, -4);
    }
    if (req.params.TransactionId)
        lookup.TransactionId = parseInt(req.params.TransactionId);
    if (req.params._id)
        lookup.TransactionId = parseInt(req.params._id);
    let filterProperty = req.query.filter;
    myLog.debug(`filterProperty: ${filterProperty}`);
    //url filter should look like: PeriodBeginDate=2018-12-31,PeriodEndDate=2019-03-31
    //want it to look like: {  ClientInternalId: 12345 ,...blah..., $and: [{ PeriodStartDt: { $gt: "2018-12-31" } }, { PeriodStartDt: { $lt: "2019-01-02" } }] }
    let periodFilter = (filterProperty || "").split(",");
    let periodBeginFilter = (periodFilter[0] || "PeriodBeginDate=2000-01-01").split("=")[1] || "2000-01-01";
    let periodEndFilter = (periodFilter[1] || "PeriodEndDate=9999-31-12").split("=")[1] || "9999-31-12";
    let filter = [{ PeriodStartDt: { $gt: "2000-01-10" } }, { PeriodStartDt: { $lt: "9999-31-12" } }];
    filter[0].PeriodStartDt.$gt = periodBeginFilter;
    filter[1].PeriodStartDt.$lt = periodEndFilter;
    // todo: can't get dates to work  
    // lookup.$and = filter;
    // tried: https://stackoverflow.com/questions/19819870/date-query-with-isodate-in-mongodb-doesnt-seem-to-work
    // lookup = {PeriodStartDt:{$gte:"2019-01-01"}}
    // lookup = {PeriodStartDt: {"$gte" : new Date("2013-10-01").toISOString() } };
    // lookup = {ClientInternalId:12345,AccountSequenceNumber:1,RoleTypeCode:5,FormType:"myFT6",TransactionId:1122330};
    // lookup = {ClientInternalId:12345,AccountSequenceNumber:1,RoleTypeCode:5,FormType:"myFT6",TransactionId:1122330,$and:[{PeriodStartDt:{$gt:"2018-12-31"}},{PeriodStartDt:{$lt:"2019-03-31"}}]};
    // lookup = {$and:[{PeriodStartDt:{$gt:"2018-12-31"}}]};
    // this one does work because its not a date: lookup.AccountSequenceNumber = {$gt: 0}
    //todo: add form line item filter properties...
    lookup = addOptimisticLockingConstraint(lookup, req.body);
    if (req.params.ClientIdentifierType && req.params.ClientIdentifierValue) {
        lookup['subjectClient.ClientIdentifierType'] = req.params.ClientIdentifierType;
        //todo: can't remember why I'm multiplying by 1
        lookup['subjectClient.ClientIdentifierValue'] = req.params.ClientIdentifierValue * 1;
    }
    myLog.debug(`Looking up database with: ${JSON.stringify(lookup)}`);
    if (!req.params.ClientInternalId && !(req.params.ClientIdentifierType && req.params.ClientIdentifierValue))
        next(new Error("No Client Identifier, so who am I doing this for??"));
    const doingFormIdentity = req.path.indexOf('/FormIdentity/') > 1;
    if ((req.method == "PUT" || req.method == "DELETE") && !doingFormIdentity && !req.params.TransactionId)
        next(new Error("No Transaction Id"));
    return lookup;
}
exports.turnURLStemsIntoLookupObject = turnURLStemsIntoLookupObject;
// add DT/TM_Update for optimistic locking check (double update will result in "not found", 
// which may result in an insert with duplicate Transaction_Id, hence unique index violation)
function addOptimisticLockingConstraint(lookup, tobeForm) {
    if (tobeForm.DT_Update) {
        lookup.DT_Update = tobeForm.DT_Update;
        lookup.TM_Update = tobeForm.TM_Update;
    }
    return lookup;
}
exports.addOptimisticLockingConstraint = addOptimisticLockingConstraint;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiRm9ybVVSTDJRdWVyeS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIkZvcm1VUkwyUXVlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsbURBQXFDO0FBRXJDLHFEQUE4QztBQUM5QyxLQUFLLENBQUMsS0FBSyxDQUFDLGtCQUFrQixDQUFDLENBQUM7QUF1QmhDLFNBQWdCLDRCQUE0QixDQUFDLEdBQW9CLEVBQUUsSUFBMEI7SUFDN0YsSUFBSSxNQUFNLEdBQWtCLEVBQUUsQ0FBQztJQUUzQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsZ0JBQWdCO1FBQzNCLE1BQU0sQ0FBQyxnQkFBZ0IsR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBRXBFLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxxQkFBcUI7UUFDaEMsTUFBTSxDQUFDLHFCQUFxQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLHFCQUFxQixDQUFDLENBQUM7SUFFOUUsSUFBSSxHQUFHLENBQUMsTUFBTSxDQUFDLG1CQUFtQjtRQUM5QixNQUFNLENBQUMsWUFBWSxHQUFHLDJCQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO0lBRXJFLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhO1FBQ3hCLE1BQU0sQ0FBQyxhQUFhLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUM7SUFFcEQsb0ZBQW9GO0lBQ3BGLElBQUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxZQUFZLEVBQUU7UUFDekIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLFdBQVcsRUFBRSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUM7WUFDdkQsSUFBSSxDQUFDLElBQUksS0FBSyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQztRQUM3QyxNQUFNLENBQUMsUUFBUSxH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RyxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsSUFBSSxDQUFDLGlCQUFpQixJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxhQUFhO1FBQ2xHLElBQUksQ0FBQyxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUM7SUFFekMsT0FBTyxNQUFNLENBQUM7QUFDbEIsQ0FBQztBQW5FRCxvRUFtRUM7QUFHRCw0RkFBNEY7QUFDNUYsNkZBQTZGO0FBQzdGLFNBQWdCLDhCQUE4QixDQUFDLE1BQXFCLEVBQUUsUUFBYTtJQUNqRixJQUFJLFFBQVEsQ0FBQyxTQUFTLEVBQUM7UUFDbkIsTUFBTSxDQUFDLFNBQVMsR0FBRyxRQUFRLENBQUMsU0FBUyxDQUFDO1FBQ3RDLE1BQU0sQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztLQUN6QztJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2hCLENBQUM7QUFORCx3RUFNQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIG15TG9nIGZyb20gJy4uLy4uL215TG9nJztcclxuaW1wb3J0ICogYXMgZXhwcmVzcyBmcm9tICdleHByZXNzJztcclxuaW1wb3J0IHsgY29kZUxvb2t1cCB9IGZyb20gJy4vRm9ybUNvbnRyb2xsZXInO1xyXG5teUxvZy5kZWJ1ZyhcImluIEZvcm1VUkwyUXVlcnlcIik7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIGZvcm1RdWVyeVR5cGUge1xyXG4gICAgQ2xpZW50SW50ZXJuYWxJZD86IG51bWJlcjtcclxuICAgIEFjY291bnRTZXF1ZW5jZU51bWJlcj86IG51bWJlcjtcclxuICAgIFJvbGVUeXBlQ29kZT86IG51bWJlcjtcclxuICAgIFBlcmlvZFN0YXJ0RHQ/OiBhbnk7XHJcbiAgICBGb3JtVHlwZT86IHN0cmluZztcclxuICAgIFRyYW5zYWN0aW9uSWQ/OiBudW1iZXI7XHJcbiAgICBEVF9VcGRhdGU/OiBzdHJpbmc7XHJcbiAgICBUTV9VcGRhdGU/OiBzdHJpbmc7XHJcbiAgICBfaWQ/OiBhbnk7XHJcbiAgICAkYW5kPzogb2JqZWN0O1xyXG4gICAgLy9zdWJqZWN0Q2xpZW50Pzogc3ViamVjdENsaWVudDtcclxuICAgIFtpbmRleDogc3RyaW5nXTogYW55O1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIHN1YmplY3RDbGllbnQgeyAvL3RoaXMgaXNuJ3QgYWN0dWFsbHkgdXNlZFxyXG4gICAgQ2xpZW50SWRlbnRpZmllclR5cGU/OiBzdHJpbmc7XHJcbiAgICBDbGllbnRJZGVudGlmaWVyVmFsdWU/OiBudW1iZXI7XHJcbiAgICBNYXRjaGluZ1N0YXR1cz86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHR1cm5VUkxTdGVtc0ludG9Mb29rdXBPYmplY3QocmVxOiBleHByZXNzLlJlcXVlc3QsIG5leHQ6IGV4cHJlc3MuTmV4dEZ1bmN0aW9uKTogZm9ybVF1ZXJ5VHlwZSB7XHJcbmxldCBsb29rdXA6IGZvcm1RdWVyeVR5cGUgPSB7fTtcclxuXHJcbiAgICBpZiAocmVxLnBhcmFtcy5DbGllbnRJbnRlcm5hbElkKVxyXG4gICAgICAgIGxvb2t1cC5DbGllbnRJbnRlcm5hbElkID0gcGFyc2VJbnQocmVxLnBhcmFtcy5DbGllbnRJbnRlcm5hbElkKTtcclxuICAgIFxyXG4gICAgaWYgKHJlcS5wYXJhbXMuQWNjb3VudFNlcXVlbmNlTnVtYmVyKVxyXG4gICAgICAgIGxvb2t1cC5BY2NvdW50U2VxdWVuY2VOdW1iZXIgPSBwYXJzZUludChyZXEucGFyYW1zLkFjY291bnRTZXF1ZW5jZU51bWJlcik7XHJcbiAgICBcclxuICAgIGlmIChyZXEucGFyYW1zLlJvbGVUeXBlU2hvcnREZWNvZGUpXHJcbiAgICAgICAgbG9va3VwLlJvbGVUeXBlQ29kZSA9IGNvZGVMb29rdXAocmVxLnBhcmFtcy5Sb2xlVHlwZVNob3J0RGVjb2RlKTtcclxuICAgIFxyXG4gICAgaWYgKHJlcS5wYXJhbXMuUGVyaW9kU3RhcnREdClcclxuICAgICAgICBsb29rdXAuUGVyaW9kU3RhcnREdCA9IHJlcS5wYXJhbXMuUGVyaW9kU3RhcnREdDtcclxuICAgIFxyXG4gICAgLy9zdHJpcCBhIFwiRm9ybVwiIHN1ZmZpeCBvZmYgaGVyZS4gIEl0cyBkdW1iLiBCdXQgdHJ5aW5nIHRvIGFsaWduIHdpdGggcHVibGlzaGVkIFVSSS5cclxuICAgIGlmIChyZXEucGFyYW1zLkZvcm1UeXBlTXVuZykge1xyXG4gICAgICAgIGlmICghcmVxLnBhcmFtcy5Gb3JtVHlwZU11bmcudG9Mb3dlckNhc2UoKS5lbmRzV2l0aChcImZvcm1cIikpXHJcbiAgICAgICAgICAgIG5leHQobmV3IEVycm9yKFwiSW52YWxpZCBGb3JtVHlwZSBTdGVtXCIpKTtcclxuICAgICAgICBsb29rdXAuRm9ybVR5cGUgPSByZXEucGFyYW1zLkZvcm1UeXBlTXVuZy5zbGljZSgwLCAtNCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChyZXEucGFyYW1zLlRyYW5zYWN0aW9uSWQpXHJcbiAgICAgICAgbG9va3VwLlRyYW5zYWN0aW9uSWQgPSBwYXJzZUludChyZXEucGFyYW1zLlRyYW5zYWN0aW9uSWQpO1xyXG4gICAgXHJcbiAgICBpZiAocmVxLnBhcmFtcy5faWQpXHJcbiAgICAgICAgbG9va3VwLlRyYW5zYWN0aW9uSWQgPSBwYXJzZUludChyZXEucGFyYW1zLl9pZCk7ICBcclxuICAgIFxyXG4gICAgbGV0IGZpbHRlclByb3BlcnR5OiBzdHJpbmcgPSA8c3RyaW5nPiByZXEucXVlcnkuZmlsdGVyO1xyXG4gICAgbXlMb2cuZGVidWcoYGZpbHRlclByb3BlcnR5OiAke2ZpbHRlclByb3BlcnR5fWApO1xyXG4gICAgLy91cmwgZmlsdGVyIHNob3VsZCBsb29rIGxpa2U6IFBlcmlvZEJlZ2luRGF0ZT0yMDE4LTEyLTMxLFBlcmlvZEVuZERhdGU9MjAxOS0wMy0zMVxyXG4gICAgLy93YW50IGl0IHRvIGxvb2sgbGlrZTogeyAgQ2xpZW50SW50ZXJuYWxJZDogMTIzNDUgLC4uLmJsYWguLi4sICRhbmQ6IFt7IFBlcmlvZFN0YXJ0RHQ6IHsgJGd0OiBcIjIwMTgtMTItMzFcIiB9IH0sIHsgUGVyaW9kU3RhcnREdDogeyAkbHQ6IFwiMjAxOS0wMS0wMlwiIH0gfV0gfVxyXG4gICAgbGV0IHBlcmlvZEZpbHRlciA9IChmaWx0ZXJQcm9wZXJ0eSB8fCBcIlwiKS5zcGxpdChcIixcIik7XHJcbiAgICBsZXQgcGVyaW9kQmVnaW5GaWx0ZXIgPSAocGVyaW9kRmlsdGVyWzBdIHx8IFwiUGVyaW9kQmVnaW5EYXRlPTIwMDAtMDEtMDFcIikuc3BsaXQoXCI9XCIpWzFdIHx8IFwiMjAwMC0wMS0wMVwiO1xyXG4gICAgbGV0IHBlcmlvZEVuZEZpbHRlciA9IChwZXJpb2RGaWx0ZXJbMV0gfHwgXCJQZXJpb2RFbmREYXRlPTk5OTktMzEtMTJcIikuc3BsaXQoXCI9XCIpWzFdIHx8IFwiOTk5OS0zMS0xMlwiO1xyXG4gICAgbGV0IGZpbHRlciA9IFt7IFBlcmlvZFN0YXJ0RHQ6IHsgJGd0OiBcIjIwMDAtMDEtMTBcIiB9IH0sIHsgUGVyaW9kU3RhcnREdDogeyAkbHQ6IFwiOTk5OS0zMS0xMlwiIH0gfV07XHJcbiAgICBmaWx0ZXJbMF0uUGVyaW9kU3RhcnREdC4kZ3QgPSBwZXJpb2RCZWdpbkZpbHRlcjtcclxuICAgIGZpbHRlclsxXS5QZXJpb2RTdGFydER0LiRsdCA9IHBlcmlvZEVuZEZpbHRlcjtcclxuICAgIC8vIHRvZG86IGNhbid0IGdldCBkYXRlcyB0byB3b3JrICBcclxuICAgIC8vIGxvb2t1cC4kYW5kID0gZmlsdGVyO1xyXG4gICAgLy8gdHJpZWQ6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE5ODE5ODcwL2RhdGUtcXVlcnktd2l0aC1pc29kYXRlLWluLW1vbmdvZGItZG9lc250LXNlZW0tdG8td29ya1xyXG4gICAgLy8gbG9va3VwID0ge1BlcmlvZFN0YXJ0RHQ6eyRndGU6XCIyMDE5LTAxLTAxXCJ9fVxyXG4gICAgLy8gbG9va3VwID0ge1BlcmlvZFN0YXJ0RHQ6IHtcIiRndGVcIiA6IG5ldyBEYXRlKFwiMjAxMy0xMC0wMVwiKS50b0lTT1N0cmluZygpIH0gfTtcclxuICAgIC8vIGxvb2t1cCA9IHtDbGllbnRJbnRlcm5hbElkOjEyMzQ1LEFjY291bnRTZXF1ZW5jZU51bWJlcjoxLFJvbGVUeXBlQ29kZTo1LEZvcm1UeXBlOlwibXlGVDZcIixUcmFuc2FjdGlvbklkOjExMjIzMzB9O1xyXG4gICAgLy8gbG9va3VwID0ge0NsaWVudEludGVybmFsSWQ6MTIzNDUsQWNjb3VudFNlcXVlbmNlTnVtYmVyOjEsUm9sZVR5cGVDb2RlOjUsRm9ybVR5cGU6XCJteUZUNlwiLFRyYW5zYWN0aW9uSWQ6MTEyMjMzMCwkYW5kOlt7UGVyaW9kU3RhcnREdDp7JGd0OlwiMjAxOC0xMi0zMVwifX0se1BlcmlvZFN0YXJ0RHQ6eyRsdDpcIjIwMTktMDMtMzFcIn19XX07XHJcbiAgICAvLyBsb29rdXAgPSB7JGFuZDpbe1BlcmlvZFN0YXJ0RHQ6eyRndDpcIjIwMTgtMTItMzFcIn19XX07XHJcbiAgICAvLyB0aGlzIG9uZSBkb2VzIHdvcmsgYmVjYXVzZSBpdHMgbm90IGEgZGF0ZTogbG9va3VwLkFjY291bnRTZXF1ZW5jZU51bWJlciA9IHskZ3Q6IDB9XHJcbiAgICAvL3RvZG86IGFkZCBmb3JtIGxpbmUgaXRlbSBmaWx0ZXIgcHJvcGVydGllcy4uLlxyXG4gICAgXHJcbiAgICBsb29rdXAgPSBhZGRPcHRpbWlzdGljTG9ja2luZ0NvbnN0cmFpbnQobG9va3VwLCByZXEuYm9keSk7XHJcbiAgICBcclxuICAgIGlmIChyZXEucGFyYW1zLkNsaWVudElkZW50aWZpZXJUeXBlICYmIHJlcS5wYXJhbXMuQ2xpZW50SWRlbnRpZmllclZhbHVlKSB7XHJcbiAgICAgICAgbG9va3VwWydzdWJqZWN0Q2xpZW50LkNsaWVudElkZW50aWZpZXJUeXBlJ109cmVxLnBhcmFtcy5DbGllbnRJZGVudGlmaWVyVHlwZTtcclxuICAgICAgICAvL3RvZG86IGNhbid0IHJlbWVtYmVyIHdoeSBJJ20gbXVsdGlwbHlpbmcgYnkgMVxyXG4gICAgICAgIGxvb2t1cFsnc3ViamVjdENsaWVudC5DbGllbnRJZGVudGlmaWVyVmFsdWUnXT08YW55PnJlcS5wYXJhbXMuQ2xpZW50SWRlbnRpZmllclZhbHVlICogMTtcclxuICAgIH1cclxuXHJcbiAgICBteUxvZy5kZWJ1ZyhgTG9va2luZyB1cCBkYXRhYmFzZSB3aXRoOiAke0pTT04uc3RyaW5naWZ5KGxvb2t1cCl9YCk7XHJcbiAgICBcclxuICAgIGlmICghcmVxLnBhcmFtcy5DbGllbnRJbnRlcm5hbElkICYmICEocmVxLnBhcmFtcy5DbGllbnRJZGVudGlmaWVyVHlwZSAmJiByZXEucGFyYW1zLkNsaWVudElkZW50aWZpZXJWYWx1ZSkpXHJcbiAgICAgICAgbmV4dChuZXcgRXJyb3IoXCJObyBDbGllbnQgSWRlbnRpZmllciwgc28gd2hvIGFtIEkgZG9pbmcgdGhpcyBmb3I/P1wiKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRvaW5nRm9ybUlkZW50aXR5ID0gcmVxLnBhdGguaW5kZXhPZignL0Zvcm1JZGVudGl0eS8nKSA+IDFcclxuICAgIGlmICgocmVxLm1ldGhvZCA9PSBcIlBVVFwiIHx8IHJlcS5tZXRob2QgPT0gXCJERUxFVEVcIikgJiYgIWRvaW5nRm9ybUlkZW50aXR5ICYmICFyZXEucGFyYW1zLlRyYW5zYWN0aW9uSWQgIClcclxuICAgICAgICBuZXh0KG5ldyBFcnJvcihcIk5vIFRyYW5zYWN0aW9uIElkXCIpKTtcclxuXHJcbiAgICByZXR1cm4gbG9va3VwO1xyXG59XHJcblxyXG5cclxuLy8gYWRkIERUL1RNX1VwZGF0ZSBmb3Igb3B0aW1pc3RpYyBsb2NraW5nIGNoZWNrIChkb3VibGUgdXBkYXRlIHdpbGwgcmVzdWx0IGluIFwibm90IGZvdW5kXCIsIFxyXG4vLyB3aGljaCBtYXkgcmVzdWx0IGluIGFuIGluc2VydCB3aXRoIGR1cGxpY2F0ZSBUcmFuc2FjdGlvbl9JZCwgaGVuY2UgdW5pcXVlIGluZGV4IHZpb2xhdGlvbilcclxuZXhwb3J0IGZ1bmN0aW9uIGFkZE9wdGltaXN0aWNMb2NraW5nQ29uc3RyYWludChsb29rdXA6IGZvcm1RdWVyeVR5cGUsIHRvYmVGb3JtOiBhbnkpIHtcclxuICBpZiAodG9iZUZvcm0uRFRfVXBkYXRlKXtcclxuICAgICAgbG9va3VwLkRUX1VwZGF0ZSA9IHRvYmVGb3JtLkRUX1VwZGF0ZTtcclxuICAgICAgbG9va3VwLlRNX1VwZGF0ZSA9IHRvYmVGb3JtLlRNX1VwZGF0ZTtcclxuICB9XHJcbiAgcmV0dXJuIGxvb2t1cDtcclxufVxyXG4iXX0=